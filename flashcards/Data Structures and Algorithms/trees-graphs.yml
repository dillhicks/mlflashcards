subject: Trees and  Graphs
description: Fundamental concepts, structures, and algorithms for technical interviews.
cards:
  - front: |
      # **DFS vs. BFS** for Tree Traversal 

      What are the key differences in how they explore a tree?
    back: |
      ## Depth-First Search (DFS)
      DFS explores as far as possible down one branch before backtracking. It uses a **stack** (often the implicit call stack via recursion).

      **Analogy**: Navigating a maze by always taking the rightmost path until you hit a dead end, then backtracking.

      ### Common DFS Orders:
      - **Pre-order**: `Root -> Left -> Right`
      - **In-order**: `Left -> Root -> Right` (for BSTs, this gives sorted order)
      - **Post-order**: `Left -> Right -> Root`

      ## Breadth-First Search (BFS)
      BFS explores all the neighbors at the present depth level before moving on to the nodes at the next depth level. It uses a **queue**.

      **Analogy**: Spreading a wave outwards from a starting point, level by level.

  - front: |
      # **Code**: Tree Traversal (DFS)

      Provide a Python implementation for DFS on a binary tree (Pre-order, In-order, Post-order).
    back: |
      ```python
      class TreeNode:
          def __init__(self, val=0, left=None, right=None):
              self.val = val
              self.left = left
              self.right = right

      def preorder_traversal(root):
          # Root -> Left -> Right
          if not root:
              return []
          return [root.val] + preorder_traversal(root.left) + preorder_traversal(root.right)

      def inorder_traversal(root):
          # Left -> Root -> Right
          if not root:
              return []
          return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)

      def postorder_traversal(root):
          # Left -> Right -> Root
          if not root:
              return []
          return postorder_traversal(root.left) + postorder_traversal(root.right) + [root.val]
      ```

  - front: |
      # **Code**: Tree Traversal (BFS)

      Provide a Python implementation for BFS on a binary tree.
    back: |
      ```python
      from collections import deque

      class TreeNode:
          def __init__(self, val=0, left=None, right=None):
              self.val = val
              self.left = left
              self.right = right

      def bfs_traversal(root):
          # Level-by-level traversal
          if not root:
              return []

          result = []
          queue = deque([root]) # Use a queue for BFS

          while queue:
              node = queue.popleft() # Dequeue the node at the front
              result.append(node.val)

              if node.left:
                  queue.append(node.left)
              if node.right:
                  queue.append(node.right)
          
          return result
      ```

  - front: |
      # **Code**: Graph Traversal (DFS)

      Provide a Python implementation for DFS on a graph using an adjacency list.
    back: |
      ```python
      def dfs_graph(graph, start_node):
          """
          Performs DFS on a graph represented by an adjacency list.
          'graph' is a dict like: {'A': ['B', 'C'], 'B': ['A', 'D'], ...}
          """
          visited = set()
          stack = [start_node]
          result = []

          while stack:
              node = stack.pop()

              if node not in visited:
                  visited.add(node)
                  result.append(node)

                  # Add unvisited neighbors to the stack
                  for neighbor in graph.get(node, []):
                      if neighbor not in visited:
                          stack.append(neighbor)
          
          return result
      ```

  - front: |
      # **Code**: Graph Traversal (BFS)

      Provide a Python implementation for BFS on a graph using an adjacency list.
    back: |
      ```python
      from collections import deque

      def bfs_graph(graph, start_node):
          """Performs BFS on a graph represented by an adjacency list.

          'graph' is a dict like: {'A': ['B', 'C'], 'B': ['A', 'D'], ...}
          """
          visited = set([start_node])
          queue = deque([start_node])
          result = []

          while queue:
              node = queue.popleft()
              result.append(node)

              # Add unvisited neighbors to the queue
              for neighbor in graph.get(node, []):
                  if neighbor not in visited:
                      visited.add(neighbor)
                      queue.append(neighbor)
          
          return result
      ```

  - front: |
      # **Code**: Delete a Node from a Singly Linked List

      Provide a Python implementation to delete a node with a given value.
    back: |
      ```python
      class ListNode:
          def __init__(self, val=0, next=None):
              self.val = val
              self.next = next

      def delete_node(head, key_to_delete):
          temp = head
          prev = None

          # Case 1: The head node holds the key
          if temp is not None and temp.val == key_to_delete:
              head = temp.next
              return head

          # Case 2: Search for the key, keeping track of the previous node
          while temp is not None and temp.val != key_to_delete:
              prev = temp
              temp = temp.next

          # If the key was not present in the list
          if temp is None:
              return head

          # Unlink the node from the list
          prev.next = temp.next

          return head
      ```